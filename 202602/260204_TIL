1. [알고리즘 이론]

  1) 그래프
  * 정의 : 노드와 에지로 구성된 집합
  * 노드 : 데이터를 표현하는 단위
  * 에지 : 노드를 연결
  * 종류 : 유니온 파인드, 위상 정렬, 다익스트라, 벨만-포드, 플로이드-워셜, 최소 신장 트리


2) 그래프의 표현
[에지 리스트]
* 에지를 중심으로 그래프를 표현
* 배열에 출발 노드, 도착 노드를 저장하여 에지를 표현
* 출발 노드, 도착 노드, 가중치를 저장하여 가중치가 있는 에지를 표현

[에지 리스트로 가중치 없는 그래프 표현하기]
* 가중치가 없는 그래프는 출발 노드와 도착 노드만 표현하므로, 배열의 행은 2개면 충분

[에지 리스트로 가중치 있는 그래프 표현하기]
* 가중치가 있는 그래프는 행을 3개로 늘려 3번째 행에 가중치를 저장하면 됨

-> 에지 리스트는 벨만 포드나 크루스칼 알고리즘에 사용

[인접 행렬]
* 2차원 배열을 이용하여 그래프를 표현
* 노드 중심으로 그래프를 표현
* 하지만 노드와 관련되어 있는 에지를 탐색하려면 N번 접근해야 하므로 노드 개수에 비해 에지가 적을 때는 공간 효율성이 떨어짐
* 노드 개수가 많은 경우 아예 2차원 배열 선언 자체를 할 수 없는 결함도 있음 -> 자바 힙 스페이스 에러가 발생할 수도 있다.

[인접 리스트]
* 인접 리스트는 ArrayList로 그래프를 표현함
* 노드 개수만큼 ArrayList를 선언
* 그래프 구현은 복잡하지만, 노드와 연결되어 있는 에지를 탐색하는 시간은 매우 뛰어남
* 노드 개수가 커도 공간 효율이 좋아 메모리 초과 에러도 발생하지 않음
* 이런 장점으로 실제 코딩 테스트에서는 인접 리스트를 이용한 그래프 구현을 선호

[ArrayList 형 배열 - 인접 리스트에서 쓰이는 자료구조]
ArrayList<Integer>[] graph  // ArrayList 객체를 저장하는 배열
graph[0] → ArrayList
graph[1] → ArrayList
graph[2] → ArrayList
=> 배열 안에 ArrayList 저장

다음 코드만 하면 아직 리스트 없음
ArrayList<Integer>[] graph = new ArrayList[5]; 

현재 상태는 
graph[0] → null
graph[1] → null
graph[2] → null
=> 배열 칸만 만들어지고, 리스트는 아직 생성 안됨

그래서 반드시 이것도 해야한다.
for(int i=0; i<5; i++) {
  graph[i] = new ArrayList<>();
}

그러면 구조가 이렇게 바뀐다.
graph[0] → []
graph[1] → []
graph[2] → []
=> 각 칸에 리스트 생성 완료

값은 다음과 같이 넣으면 된다.
graph[1].add(2);
graph[1].add(3);
=> graph[1] → [2,3]

